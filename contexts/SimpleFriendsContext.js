// Contexto simples e confi√°vel para sistema de amigos
import React, { createContext, useContext, useState, useEffect } from 'react';
import { useAuth } from './AuthContext';

const SimpleFriendsContext = createContext();

export const useSimpleFriends = () => {
  const context = useContext(SimpleFriendsContext);
  if (!context) {
    throw new Error('useSimpleFriends deve ser usado dentro de um SimpleFriendsProvider');
  }
  return context;
};

export const SimpleFriendsProvider = ({ children }) => {
  const { isAuthenticated, user, renewToken, isLoading: authLoading } = useAuth();

  const [friends, setFriends] = useState([]);
  const [requests, setRequests] = useState([]);
  const [sentRequests, setSentRequests] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  // Fun√ß√£o para obter ID do usu√°rio atual
  const getCurrentUserId = () => {
    if (user && user.username) {
      return `auth_${user.username}`;
    }
    return null;
  };

  // Fun√ß√£o para salvar dados no cache local
  const saveFriendsCache = (friendsData, requestsData, sentData) => {
    const userId = getCurrentUserId();
    if (!userId) return;

    try {
      localStorage.setItem(`simple_friends_${userId}`, JSON.stringify(friendsData));
      localStorage.setItem(`simple_requests_${userId}`, JSON.stringify(requestsData));
      localStorage.setItem(`simple_sent_${userId}`, JSON.stringify(sentData));
    } catch (error) {
      console.warn('Erro ao salvar cache dos amigos:', error);
    }
  };

  // Fun√ß√£o para carregar dados do cache local
  const loadFriendsCache = () => {
    const userId = getCurrentUserId();
    if (!userId) return { friends: [], requests: [], sent: [] };

    try {
      const friendsData = localStorage.getItem(`simple_friends_${userId}`);
      const requestsData = localStorage.getItem(`simple_requests_${userId}`);
      const sentData = localStorage.getItem(`simple_sent_${userId}`);

      return {
        friends: friendsData ? JSON.parse(friendsData) : [],
        requests: requestsData ? JSON.parse(requestsData) : [],
        sent: sentData ? JSON.parse(sentData) : []
      };
    } catch (error) {
      console.warn('Erro ao carregar cache dos amigos:', error);
      return { friends: [], requests: [], sent: [] };
    }
  };

  // Fun√ß√£o para limpar cache local
  const clearFriendsCache = () => {
    const userId = getCurrentUserId();
    if (!userId) return;

    try {
      localStorage.removeItem(`simple_friends_${userId}`);
      localStorage.removeItem(`simple_requests_${userId}`);
      localStorage.removeItem(`simple_sent_${userId}`);
    } catch (error) {
      console.warn('Erro ao limpar cache dos amigos:', error);
    }
  };

  // Fun√ß√£o para obter token de autentica√ß√£o
  const getAuthToken = () => {
    // Tentar obter token de v√°rias fontes
    const token = localStorage.getItem('ludomusic_session_token') ||
                  document.cookie.split('; ').find(row => row.startsWith('ludomusic_session='))?.split('=')[1];
    return token;
  };

  // Fun√ß√£o para fazer requisi√ß√µes autenticadas com retry autom√°tico
  const apiRequest = async (url, options = {}) => {
    let token = getAuthToken();
    if (!token) {
      throw new Error('Token de autentica√ß√£o n√£o encontrado');
    }

    const requestOptions = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        ...options.headers
      }
    };

    let response = await fetch(url, requestOptions);

    // Se recebeu 401, tentar renovar token uma vez
    if (response.status === 401) {
      console.log('üîÑ Token expirado, tentando renovar...');
      try {
        const renewResult = await renewToken();

        if (renewResult?.success) {
          console.log('‚úÖ Token renovado com sucesso');
          // Atualizar token e tentar novamente
          token = getAuthToken();
          requestOptions.headers['Authorization'] = `Bearer ${token}`;
          response = await fetch(url, requestOptions);
        } else {
          console.log('‚ùå Falha na renova√ß√£o do token');
        }
      } catch (renewError) {
        console.log('‚ùå Erro ao renovar token:', renewError);
      }
    }

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Erro na requisi√ß√£o');
    }

    return response.json();
  };

  // Carregar dados dos amigos
  const loadFriendsData = async () => {
    if (!isAuthenticated || authLoading) return;

    // Verificar se h√° token antes de fazer requisi√ß√µes
    const token = getAuthToken();
    if (!token) {
      console.warn('Token n√£o dispon√≠vel ainda, aguardando...');
      return;
    }

    setIsLoading(true);
    try {
      // Carregar amigos
      const friendsData = await apiRequest('/api/simple-friends?action=friends');
      const friends = friendsData.friends || [];
      setFriends(friends);

      // Carregar solicita√ß√µes recebidas
      const requestsData = await apiRequest('/api/simple-friends?action=requests');
      const requests = requestsData.requests || [];
      setRequests(requests);

      // Carregar solicita√ß√µes enviadas
      const sentData = await apiRequest('/api/simple-friends?action=sent');
      const sent = sentData.sent || [];
      setSentRequests(sent);

      // Salvar no cache local
      saveFriendsCache(friends, requests, sent);

    } catch (error) {
      // Se o erro for de token n√£o encontrado, n√£o logar como erro (√© esperado durante carregamento)
      if (error.message.includes('Token de autentica√ß√£o n√£o encontrado')) {
        console.warn('Token ainda n√£o dispon√≠vel, usando cache...');
      } else {
        console.error('Erro ao carregar dados dos amigos:', error);
      }

      // Em caso de erro, tentar carregar do cache
      const cachedData = loadFriendsCache();
      setFriends(cachedData.friends);
      setRequests(cachedData.requests);
      setSentRequests(cachedData.sent);
    } finally {
      setIsLoading(false);
    }
  };

  // Buscar usu√°rio por c√≥digo
  const searchUser = async (userCode) => {
    if (!userCode || !userCode.trim()) {
      throw new Error('C√≥digo do usu√°rio √© obrigat√≥rio');
    }

    if (!isAuthenticated || !user) {
      throw new Error('Voc√™ precisa estar logado para buscar usu√°rios');
    }

    try {
      const currentUserId = `auth_${user.username}`;
      const response = await fetch(`/api/search-users?query=${encodeURIComponent(userCode.trim())}&currentUserId=${encodeURIComponent(currentUserId)}`);

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao buscar usu√°rio');
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.message || 'Usu√°rio n√£o encontrado');
      }

      return data.user;
    } catch (error) {
      throw error;
    }
  };

  // Enviar solicita√ß√£o de amizade
  const sendFriendRequest = async (user) => {
    if (!user || !user.id) {
      throw new Error('Dados do usu√°rio s√£o obrigat√≥rios');
    }

    try {
      await apiRequest('/api/simple-friends', {
        method: 'POST',
        body: JSON.stringify({
          action: 'send_request',
          data: {
            toUserId: user.id,
            toUser: {
              username: user.username,
              displayName: user.displayName,
              avatar: user.avatar
            }
          }
        })
      });

      // Recarregar dados
      await loadFriendsData();
    } catch (error) {
      throw error;
    }
  };

  // Aceitar solicita√ß√£o de amizade
  const acceptFriendRequest = async (requestId) => {
    if (!requestId) {
      throw new Error('ID da solicita√ß√£o √© obrigat√≥rio');
    }

    try {
      await apiRequest('/api/simple-friends', {
        method: 'POST',
        body: JSON.stringify({
          action: 'accept_request',
          data: { requestId }
        })
      });

      // Recarregar dados
      await loadFriendsData();
    } catch (error) {
      throw error;
    }
  };

  // Rejeitar solicita√ß√£o de amizade
  const rejectFriendRequest = async (requestId) => {
    if (!requestId) {
      throw new Error('ID da solicita√ß√£o √© obrigat√≥rio');
    }

    try {
      await apiRequest('/api/simple-friends', {
        method: 'POST',
        body: JSON.stringify({
          action: 'reject_request',
          data: { requestId }
        })
      });

      // Recarregar dados
      await loadFriendsData();
    } catch (error) {
      throw error;
    }
  };

  // Remover amigo
  const removeFriend = async (friendId) => {
    if (!friendId) {
      throw new Error('ID do amigo √© obrigat√≥rio');
    }

    try {
      await apiRequest('/api/simple-friends', {
        method: 'DELETE',
        body: JSON.stringify({
          action: 'remove_friend',
          data: { friendId }
        })
      });

      // Recarregar dados
      await loadFriendsData();
    } catch (error) {
      throw error;
    }
  };

  // Cancelar solicita√ß√£o enviada
  const cancelSentRequest = async (requestId) => {
    if (!requestId) {
      throw new Error('ID da solicita√ß√£o √© obrigat√≥rio');
    }

    try {
      await apiRequest('/api/simple-friends', {
        method: 'POST',
        body: JSON.stringify({
          action: 'cancel_request',
          data: { requestId }
        })
      });

      // Recarregar dados
      await loadFriendsData();
    } catch (error) {
      throw error;
    }
  };

  // Carregar dados quando usu√°rio faz login
  useEffect(() => {
    // Aguardar o AuthContext terminar de carregar antes de tomar qualquer a√ß√£o
    if (authLoading) {
      return; // Ainda carregando, n√£o fazer nada
    }

    if (isAuthenticated && user) {
      // Usu√°rio autenticado - primeiro carregar do cache, depois do servidor
      const cachedData = loadFriendsCache();
      if (cachedData.friends.length > 0 || cachedData.requests.length > 0 || cachedData.sent.length > 0) {
        setFriends(cachedData.friends);
        setRequests(cachedData.requests);
        setSentRequests(cachedData.sent);
      }

      // Aguardar token estar dispon√≠vel antes de carregar do servidor
      const waitForTokenAndLoad = async () => {
        let attempts = 0;
        const maxAttempts = 10; // m√°ximo 1 segundo de espera

        const checkToken = () => {
          const token = getAuthToken();
          if (token) {
            loadFriendsData();
            return;
          }

          attempts++;
          if (attempts < maxAttempts) {
            setTimeout(checkToken, 100); // tentar novamente em 100ms
          } else {
            console.warn('Token n√£o dispon√≠vel ap√≥s 1 segundo, usando apenas cache');
          }
        };

        checkToken();
      };

      waitForTokenAndLoad();
    } else {
      // Usu√°rio n√£o autenticado ap√≥s carregamento completo - limpar dados e cache
      setFriends([]);
      setRequests([]);
      setSentRequests([]);
      clearFriendsCache();
    }
  }, [isAuthenticated, user?.username, authLoading]); // Usar user?.username em vez de user

  // Polling para verificar novas solicita√ß√µes (a cada 10 MINUTOS)
  useEffect(() => {
    if (!isAuthenticated || authLoading) return;

    const interval = setInterval(() => {
      loadFriendsData();
    }, 10 * 60 * 1000); // 10 MINUTOS (era 60 segundos)

    return () => clearInterval(interval);
  }, [isAuthenticated, authLoading]);

  const value = {
    friends,
    requests,
    sentRequests,
    isLoading,
    searchUser,
    sendFriendRequest,
    acceptFriendRequest,
    rejectFriendRequest,
    removeFriend,
    cancelSentRequest,
    loadFriendsData
  };

  return (
    <SimpleFriendsContext.Provider value={value}>
      {children}
    </SimpleFriendsContext.Provider>
  );
};

export default SimpleFriendsContext;
