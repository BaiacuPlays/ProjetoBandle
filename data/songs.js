import musicData from './music.json';

// FunÃ§Ã£o para normalizar caminhos de arquivo (converter \ para /)
const normalizePath = (path) => {
  if (!path) return path;
  return path.replace(/\\/g, '/');
};

// Adiciona informaÃ§Ãµes especÃ­ficas do jogo para cada mÃºsica
export const songs = (musicData.songs || musicData).map((song, index) => ({
  ...song,
  id: song.id || index + 1,
  // Normalizar tÃ­tulo removendo espaÃ§os extras
  title: song.title.trim(),
  // Normalizar caminho do Ã¡udio
  audioUrl: normalizePath(song.audioUrl),
  clips: [
    { name: "Intro", icon: "ðŸŽ¹", startTime: 0, duration: 5 },
    { name: "Meio", icon: "ðŸŽ¶", startTime: 30, duration: 5 },
    { name: "Final", icon: "ðŸŽ¤", startTime: 60, duration: 5 }
  ],
  views: "1M+",
  difficulty: "MÃ©dio",
  hint: `${song.title.trim()} - ${song.artist} (${song.game}, ${song.year})`
}));

// Cache de disponibilidade de mÃºsicas
const availabilityCache = new Map();

// Lista de mÃºsicas disponÃ­veis (que tÃªm arquivo de Ã¡udio)
const checkSongAvailability = async (song) => {
  // Verificar cache primeiro
  if (availabilityCache.has(song.audioUrl)) {
    return availabilityCache.get(song.audioUrl);
  }

  try {
    const response = await fetch(song.audioUrl, {
      method: 'HEAD',
      cache: 'force-cache' // Usar cache para melhor performance
    });
    const isAvailable = response.ok;
    availabilityCache.set(song.audioUrl, isAvailable);
    return isAvailable;
  } catch (error) {
    console.warn(`MÃºsica nÃ£o disponÃ­vel: ${song.title} - ${song.audioUrl}`);
    availabilityCache.set(song.audioUrl, false);
    return false;
  }
};

// HistÃ³rico de mÃºsicas recentes (Ãºltimas 20)
let recentSongs = [];

export const getRandomSong = async () => {
  // Check availability of all songs in parallel
  const availabilityChecks = await Promise.all(
    songs.map(async (song) => ({
      song,
      isAvailable: await checkSongAvailability(song)
    }))
  );

  // Filter available songs
  let availableSongs = availabilityChecks
    .filter(({ isAvailable }) => isAvailable)
    .map(({ song }) => song);

  // Remove as mÃºsicas que estÃ£o no histÃ³rico recente
  availableSongs = availableSongs.filter(song => !recentSongs.includes(song.id));

  // Se nÃ£o houver mÃºsicas disponÃ­veis fora do histÃ³rico, limpa o histÃ³rico
  if (availableSongs.length === 0) {
    recentSongs = [];
    availableSongs = availabilityChecks
      .filter(({ isAvailable }) => isAvailable)
      .map(({ song }) => song);
  }

  // Se ainda nÃ£o houver mÃºsicas disponÃ­veis, retorna a primeira mÃºsica
  if (availableSongs.length === 0) {
    return songs[0];
  }

  const randomIndex = Math.floor(Math.random() * availableSongs.length);
  const selectedSong = availableSongs[randomIndex];

  // Adiciona a mÃºsica selecionada ao histÃ³rico
  recentSongs.push(selectedSong.id);
  // MantÃ©m apenas as Ãºltimas 20 mÃºsicas no histÃ³rico
  if (recentSongs.length > 20) {
    recentSongs.shift();
  }

  return selectedSong;
};